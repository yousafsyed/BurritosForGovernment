"use strict";

angular.module("cpLib", ["cpLibIntegration"]);

angular.module("cpLib").factory("AddressFactory", function (ApiService) {
    return {
        getAddresses: function () {
            return ApiService.get("/addresses");
        },

        getAddressesByVendorId: function (id) {
            return ApiService.get("/addresses/vendor/" + id);
        },

        getAddressesByCustomerId: function (id) {
            return ApiService.get("/addresses/customer/" + id);
        },

        createAddress: function (address) {
            var customerId = arguments[1] === undefined ? "" : arguments[1];
            return ApiService.post("/addresses", { address: address, customerId: customerId });
        },

        updateAddress: function (id, updatedAddress) {
            return ApiService.put("/addresses/" + id, updatedAddress);
        },

        deleteAddress: function (id) {
            return ApiService["delete"]("/addresses/" + id);
        },

        createBillingAddress: function (address) {
            var customerId = arguments[1] === undefined ? "" : arguments[1];
            return ApiService.post("/addresses/billing-address", { address: address, customerId: customerId });
        }
    };
});

angular.module("cpLib").factory("AuthenticationFactory", function (ApiService) {
    return {
        login: function (loginDetails) {
            return ApiService.post("/user/login", loginDetails);
        },

        registerCustomer: function (registerDetails) {
            return ApiService.post("/user/register-customer", registerDetails);
        },

        requestResetEmail: function (email) {
            return ApiService.post("/user/request-reset-email", email);
        },

        setPassword: function (resetDetails) {
            return ApiService.post("/user/set-password", resetDetails);
        }
    };
});

angular.module("cpLib").factory("CustomersFactory", function (ApiService, $q) {
    return {
        getAllCustomers: function () {
            return ApiService.get("/customers");
        },

        getCustomer: function (id) {
            return ApiService.get("/customers/" + id);
        },

        updateCustomer: function (id, updatedCustomer) {
            return ApiService.put("/customers/" + id, updatedCustomer);
        },

        updateSelf: function (attributes) {
            return ApiService.put("/customers/self", attributes);
        },

        getAddresses: function () {
            return ApiService.get("/addresses");
        },

        getAddressById: function (id) {
            var pluckMatchingAddress = function (response) {
                var allAddresses = response.data.addresses,
                    allIds = allAddresses.map(function (address) {
                    return address.id;
                }),
                    address = allAddresses[allIds.indexOf(id)];

                if (address) {
                    return address;
                } else {
                    throw "Couldn’t find address";
                }
            };

            return ApiService.get("/addresses").then(pluckMatchingAddress);
        },

        getCustomerReviews: function (id) {
            return ApiService.get("/reviews/customer/" + id);
        },

        updatePayOnAccountDetails: function (payOnAccountDetails) {
            return ApiService.put("/customers/pay-on-account", payOnAccountDetails);
        },

        setUpRequestToPayOnAccount: function (id, payOnAccountDetails) {
            return ApiService.put("/customers/" + id + "/set-up-request-to-pay-on-account", payOnAccountDetails);
        },

        revokePaymentOnAccount: function (id) {
            return ApiService.put("/customers/" + id + "/revoke-payment-on-account");
        }
    };
});

angular.module("cpLib").factory("MealPlanFactory", function (ApiService) {
    return {
        getCustomers: function () {
            return ApiService.get("/meal-plan/customers");
        },

        getCustomerMealPlanRequirements: function (id) {
            return ApiService.get("/meal-plan/customers/" + id + "/requirements");
        },

        setCustomerMealPlanRequirements: function (id, mealPlanRequirements) {
            return ApiService.post("/meal-plan/customers/" + id + "/requirements", mealPlanRequirements);
        },

        generateMealPlan: function (id, startDate) {
            return ApiService.post("/meal-plan/customers/" + id + "/generate", { startDate: startDate });
        },

        registerForMealPlan: function (registrationDetails) {
            return ApiService.post("/meal-plan/register", registrationDetails);
        },

        getCustomerMealPlans: function (customerId) {
            return ApiService.get("/meal-plan/customers/" + customerId + "/meal-plans");
        },

        getCustomerMealPlan: function (customerId, mealPlanId) {
            return ApiService.get("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId);
        },

        checkProposedOrdersAvailability: function (customerId, mealPlanId, proposedOrders) {
            return ApiService.post("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId + "/availability", { checks: proposedOrders });
        },

        setPackagesOnDates: function (customerId, mealPlanId, orders) {
            return ApiService.post("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId + "/set-package-dates", { orders: orders });
        },

        /**
         * @param  {String} customerId
         * @param  {String} mealPlanId
         * @param  {String} date       An ISO-8601 string.
         */
        replaceWithUnusedAlternativePackage: function (customerId, mealPlanId, date) {
            return ApiService.post("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId + "/replace-with-unused-alternative-package", date);
        },

        sendToCustomer: function (customerId, mealPlanId) {
            return ApiService.post("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId + "/send-to-customer");
        },

        confirmProposedOrders: function (customerId, mealPlanId, attributes) {
            return ApiService.post("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId + "/confirm-proposed-orders", attributes);
        },

        editProposedOrder: function (customerId, mealPlanId, orderDetails) {
            return ApiService.post("/meal-plan/customers/" + customerId + "/meal-plans/" + mealPlanId + "/edit-proposed-order", orderDetails);
        }
    };
});

angular.module("cpLib").factory("OrdersFactory", function (ApiService) {
    // Cache of Date objects, to avoid having to create a new Date object many times when running
    // an array filter or sort.
    var dateObjectCache = {};

    var getDateObject = function (date) {
        if (dateObjectCache[date] === undefined) {
            dateObjectCache[date] = new Date(date);
        }

        return dateObjectCache[date];
    };

    return {
        getAllOrders: function () {
            return ApiService.get("/orders");
        },

        getOrdersByCurrentVendor: function () {
            return ApiService.get("/orders/by-current-vendor");
        },

        getOrdersByCurrentCustomer: function () {
            return ApiService.get("/orders/by-current-customer");
        },

        /**
         * Get the next order for a customer, which can have either the status 'pending vendor
         * approval' or 'accepted'.
         *
         * @return {Promise} Resolves to an order, or null if there is none.
         */
        getNextCustomerOrder: function getNextCustomerOrder() {
            return this.getOrdersByCurrentCustomer().then(function (response) {
                var orders = response.data.orders;
                if (orders.length === 0) {
                    return null;
                }

                var now = new Date();

                return orders.filter(function (order) {
                    return getDateObject(order.requestedDeliveryDate) >= now;
                }).sort(function (a, b) {
                    return getDateObject(a.requestedDeliveryDate) - getDateObject(b.requestedDeliveryDate);
                }).shift();
            });
        },

        getOrder: function (id) {
            return ApiService.get("/orders/" + id);
        },

        getOrderMessages: function (id) {
            return ApiService.get("/orders/" + id + "/messages");
        },

        getOrderReviews: function (id) {
            return ApiService.get("/reviews/order/" + id);
        },

        sendMessage: function (id, message) {
            return ApiService.put("/orders/" + id + "/messages", { message: message });
        },

        updateOrder: function (id, updatedOrder) {
            return ApiService.put("/order/" + id, updatedOrder);
        },

        deleteOrder: function (id) {
            var reason = arguments[1] === undefined ? "" : arguments[1];
            return ApiService["delete"]("/order/" + id + "?deletionReason=" + reason);
        },

        getCourierOrders: function () {
            return ApiService.get("/orders/courier");
        },

        addCustomerServiceEvent: function (id, event) {
            return ApiService.post("/order/" + id + "/customer-service-events", { event: event });
        },

        acceptOrder: function (id) {
            return ApiService.put("/order/" + id + "/accept");
        },

        addOrderReview: function (id, review) {
            return ApiService.post("/reviews/order/" + id, review);
        },

        getHeadCountOptions: function getHeadCountOptions() {
            var maxPeople = arguments[0] === undefined ? 1 : arguments[0];
            var minPeople = arguments[1] === undefined ? 1 : arguments[1];
            if (maxPeople === null) {
                maxPeople = 1000;
            }
            if (minPeople === null) {
                minPeople = 1;
            }

            var options = [];

            for (var i = minPeople; i <= maxPeople; i += 1) {
                options.push(i);
            }

            return options;
        },

        getAllCustomerInvoices: function () {
            return ApiService.get("/orders/customer-invoices");
        },

        getCustomerInvoice: function (id) {
            return ApiService.get("/orders/customer-invoice/" + id);
        },

        getCustomerInvoiceAsHtml: function (id) {
            return ApiService.get("/orders/customer-invoice-as-html/" + id);
        },

        updateCustomerInvoiceStatus: function (id, status) {
            return ApiService.put("/orders/customer-invoice/" + id + "/status", { status: status });
        },

        refundOrder: function (id, refundDetails) {
            return ApiService.put("/order/" + id + "/refund", refundDetails);
        },

        getOrderInvoices: function (orderId) {
            return ApiService.get("/orders/customer-invoices-by-order/" + orderId);
        },

        createOrder: function (orderDetails) {
            return ApiService.post("/orders", orderDetails);
        }
    };
});

angular.module("cpLib").factory("PackagesFactory", function (ApiService, getPackagingTypeTextFilter, getPackagingTypeChoiceTextFilter, getPackageDispositionTextFilter) {
    return {
        getAllPackages: function () {
            return ApiService.get("/packages");
        },

        getPackage: function (id) {
            return ApiService.get("/packages/" + id);
        },

        getPackageByHumanId: function (humanId) {
            return ApiService.get("/packages/" + humanId);
        },

        /**
         * Resolves to the name of a package.
         *
         * @param {String|Number} id Either the package ID or the package human ID.
         */
        getPackageName: function (id) {
            return ApiService.get("/packages/" + id).then(function (response) {
                return response.data.name;
            });
        },

        createPackage: function (packageDetails) {
            return ApiService.post("/packages", packageDetails);
        },

        updatePackage: function (id, updatedPackage) {
            return ApiService.put("/packages/" + id, updatedPackage);
        },

        deletePackage: function (id) {
            return ApiService["delete"]("/packages/" + id);
        },

        /**
         * @param {Promise} timeoutPromise Optional promise that is passed to the $http service as
         *                                  it's `timeout` config option. This is used to cancel a
         *                                  search if a new search request is started before the
         *                                  previous request returns.
         */
        searchPackages: function searchPackages() {
            var name = arguments[0] === undefined ? "" : arguments[0];
            var postcode = arguments[1] === undefined ? "" : arguments[1];
            var maxBudget = arguments[2] === undefined ? "" : arguments[2];
            var headCount = arguments[3] === undefined ? "" : arguments[3];
            var time = arguments[4] === undefined ? "" : arguments[4];
            var date = arguments[5] === undefined ? "" : arguments[5];
            var eventTypeIds = arguments[6] === undefined ? [] : arguments[6];
            var cuisineTypeIds = arguments[7] === undefined ? [] : arguments[7];
            var dietaryRequirementIds = arguments[8] === undefined ? [] : arguments[8];
            var packagingType = arguments[9] === undefined ? "" : arguments[9];
            var timeoutPromise = arguments[10] === undefined ? undefined : arguments[10];
            var url = "/packages/search?name=" + name + "&postcode=" + postcode + ("&maxBudget=" + maxBudget + "&headCount=" + headCount + "&time=" + time + "&date=" + date + "&packagingType=" + packagingType);

            eventTypeIds.forEach(function (eventTypeId) {
                url += "&eventTypeIds[]=" + eventTypeId;
            });

            cuisineTypeIds.forEach(function (cuisineTypeId) {
                url += "&cuisineTypeIds[]=" + cuisineTypeId;
            });

            dietaryRequirementIds.forEach(function (dietaryRequirementId) {
                url += "&dietaryRequirementIds[]=" + dietaryRequirementId;
            });

            return ApiService.get(url, { timeout: timeoutPromise });
        },

        getPackagesByVendor: function (id) {
            return ApiService.get("/packages/search/all?vendorId=" + id);
        },

        getPackagesByCurrentVendor: function () {
            return ApiService.get("/packages/by-current-vendor");
        },

        getPackageReviews: function (id) {
            return ApiService.get("/reviews/package/" + id);
        },

        getSimilarPackages: function (id) {
            return ApiService.get("/packages/" + id + "/similar");
        },

        approvePackage: function (id) {
            return ApiService.put("/packages/" + id + "/approve");
        },

        getAllergenTypes: function () {
            return ApiService.get("/allergen-types");
        },

        getDietaryTypes: function () {
            return ApiService.get("/dietary-requirements");
        },

        getEventTypes: function () {
            return ApiService.get("/event-types");
        },

        getCuisineTypes: function () {
            return ApiService.get("/cuisine-types");
        },

        getDeliveryDayOptions: function () {
            return [{ label: "Monday", value: "Monday" }, { label: "Tuesday", value: "Tuesday" }, { label: "Wednesday", value: "Wednesday" }, { label: "Thursday", value: "Thursday" }, { label: "Friday", value: "Friday" }, { label: "Saturday", value: "Saturday" }, { label: "Sunday", value: "Sunday" }];
        },

        /**
         * Gets an array of possible notice options for a package.
         *
         * If the package is a meal plan package, there is a maximum notice.
         *
         * @param  {Boolean} isForMealPlanPackage
         * @return {Array}
         */
        getNoticeOptions: function () {
            var isForMealPlanPackage = arguments[0] === undefined ? false : arguments[0];
            var allNoticeOptions = [{ label: "1 hour", value: 1 }, { label: "2 hours", value: 2 }, { label: "3 hours", value: 3 }, { label: "4 hours", value: 4 }, { label: "5 hours", value: 5 }, { label: "6 hours", value: 6 }, { label: "12 hours", value: 12 }, { label: "18 hours", value: 18 }, { label: "24 hours", value: 24 }, { label: "36 hours", value: 36 }, { label: "2 days", value: 48 }, { label: "3 days", value: 72 }, { label: "4 days", value: 96 }, { label: "5 days", value: 120 }, { label: "6 days", value: 144 }, { label: "7 days", value: 168 }, { label: "14 days", value: 336 }];

            if (isForMealPlanPackage) {
                return allNoticeOptions.slice(0, 9);
            } else {
                return allNoticeOptions;
            }
        },

        getQuantityOptions: function () {
            var i = 1;
            var step = 1;

            var options = [];

            while (i <= 6000) {
                options.push(i);

                if (30 <= i && i < 100) {
                    step = 5;
                } else if (100 <= i && i < 500) {
                    step = 25;
                } else if (500 <= i && i < 1000) {
                    step = 50;
                } else if (i >= 1000) {
                    step = 500;
                }

                i += step;
            }

            return options;
        },

        getRadiusOptions: function () {
            var options = [];

            for (var i = 1, step = 1; i <= 50; i += step) {
                options.push({
                    label: i + " mile radius",
                    value: i
                });
                if (i === 5) {
                    step = 5;
                }
            }

            return options;
        },

        getPackagingTypeOptions: function () {
            return [1, 2, 3, 4, 5].map(function (value) {
                return { value: value, label: getPackagingTypeTextFilter(value) };
            });
        },

        getPackagingTypeChoiceOptions: function () {
            return [1, 2, 3].map(function (value) {
                return { value: value, label: getPackagingTypeChoiceTextFilter(value) };
            });
        },

        /**
         * The 'start' and 'end' parameters should be the time in 24-hour clock as an integer,
         * e.g. 730 for 07:30, or 2330 for 23:30.
         *
         * @param  {Number} start
         * @param  {Number} end
         * @param  {Number} interval
         * @return {Array}
         */
        getPackageDeliveryTimeOptions: function (start, end) {
            var interval = arguments[2] === undefined ? 15 : arguments[2];
            var startMinutes = Math.floor(start / 100) * 60 + start % 100;
            var endMinutes = Math.floor(end / 100) * 60 + end % 100;

            var options = [];

            while (startMinutes <= endMinutes) {
                var hour = ("0" + Math.floor(startMinutes / 60)).slice(-2);
                var minute = ("0" + startMinutes % 60).slice(-2);

                options.push({
                    label: hour + ":" + minute,
                    value: parseInt(hour + minute, 10)
                });

                startMinutes += interval;
            }

            return options;
        },

        checkIfPackageCanBeDeliveredToPostcode: function (id, postcode) {
            return ApiService.get("/packages/" + id + "/availability?postcode=" + postcode);
        },

        checkIfPackageCanBeDelivered: function (id, date, time, postcode) {
            return ApiService.get("/packages/" + id + "/availability?date=" + date + "&time=" + time + "&postcode=" + postcode);
        },

        getRecommendedPackage: function () {
            return ApiService.get("/packages/one-recommended");
        },

        getPackageDispositionOptions: function () {
            return [1, 2].map(function (value) {
                return { value: value, label: getPackageDispositionTextFilter(value) };
            });
        }
    };
});

angular.module("cpLib").factory("PromoCodeFactory", function (ApiService) {
    return {
        getPromoCodeByCode: function (code) {
            return ApiService.get("/promo-codes/get-by-code?code=" + code);
        }
    };
});

angular.module("cpLib").factory("QuoteFactory", function (ApiService) {
    return {
        sendQuote: function (quoteDetails) {
            return ApiService.post("/quote/send-quote", quoteDetails);
        }
    };
});

angular.module("cpLib").factory("ReportingFactory", function (ApiService) {
    return {
        queryDatabase: function (query) {
            var config = {
                // Angular will try to parse responses as JSON by default. The response from this
                // API can be in any format, so turn off the JSON parsing,
                transformResponse: [function (responseContent) {
                    return responseContent;
                }]
            };
            return ApiService.post("/reporting/database-query", { query: query }, config);
        } };
});

angular.module("cpLib").factory("ReviewFactory", function (ApiService) {
    return {
        setReviewAsPublic: function (isPublic, reviewId) {
            return ApiService.put("/reviews/" + reviewId + "/set-as-public", { isPublic: isPublic });
        } };
});

angular.module("cpLib").factory("SmsFactory", function (ApiService) {
    return {
        getSms: function (id) {
            return ApiService.get("/sms/" + id);
        },

        sendSms: function (sms) {
            return ApiService.post("/sms", sms);
        },

        getSmsHistory: function () {
            return ApiService.get("/sms");
        },

        getAllSmsByNumber: function (number) {
            return ApiService.get("/sms/" + number + "/all");
        }
    };
});

angular.module("cpLib").factory("UsersFactory", function (ApiService) {
    return {
        getAllUsers: function () {
            return ApiService.get("/users");
        },

        masqueradeAsUser: function (id) {
            return ApiService.post("/user/masquerade", { id: id });
        },

        getLoggedInUser: function () {
            var id = arguments[0] === undefined ? "" : arguments[0];
            var oneTimeAuthToken = arguments[1] === undefined ? "" : arguments[1];
            return ApiService.get("/users/get-authenticated-user?userId=" + id + "&otat=" + oneTimeAuthToken);
        },

        registerVendor: function (registerDetails) {
            return ApiService.post("/user/register-vendor", registerDetails);
        },

        changeOwnPassword: function (passwords) {
            return ApiService.put("/user/self/change-password", passwords);
        },

        getPaymentCards: function () {
            return ApiService.get("/payment-cards");
        },

        addPaymentCard: function (cardDetails) {
            return ApiService.post("/payment-cards", cardDetails);
        }
    };
});

angular.module("cpLib").factory("VendorsFactory", function (ApiService, $q) {
    return {
        getAllVendors: function () {
            return ApiService.get("/vendors");
        },

        getAllActiveAndApprovedVendors: function () {
            return ApiService.get("/vendors/all-active-and-approved");
        },

        getVendor: function (idOrSlug) {
            return ApiService.get("/vendors/" + idOrSlug);
        },

        getAddresses: function () {
            return ApiService.get("/addresses");
        },

        getAddressById: function (id) {
            var pluckMatchingAddress = function (response) {
                var allAddresses = response.data.addresses,
                    allIds = allAddresses.map(function (address) {
                    return address.id;
                }),
                    address = allAddresses[allIds.indexOf(id)];

                if (address) {
                    return address;
                } else {
                    throw "Couldn’t find address";
                }
            };

            return ApiService.get("/addresses").then(pluckMatchingAddress);
        },

        getBusinessTypes: function () {
            return ApiService.get("/business-types");
        },

        getVendorReviews: function (id) {
            return ApiService.get("/reviews/vendor/" + id);
        },

        updateVendor: function (id, updatedVendor) {
            return ApiService.put("/vendors/" + id, updatedVendor);
        },

        updateSelf: function (updatedVendor) {
            return ApiService.put("/vendors/me", updatedVendor);
        },

        deleteVendor: function (id) {
            return ApiService["delete"]("/vendors/" + id);
        },

        approveVendor: function (id) {
            return ApiService.put("/vendors/" + id + "/approve");
        },

        getHolidays: function () {
            return ApiService.get("/holidays");
        },

        /**
         * @param {String} start Formatted as 'YYYY-MM-DD'.
         * @param {String} end   Formatted as 'YYYY-MM-DD'.
         */
        createHoliday: function (start, end) {
            return ApiService.post("/holidays", { start: start, end: end });
        },

        getHoliday: function (id) {
            return ApiService.get("/holidays/" + id);
        },

        updateHoliday: function (id, start, end) {
            return ApiService.put("/holidays/" + id, { start: start, end: end });
        },

        getLatestSupplierAgreement: function () {
            return ApiService.get("/supplier-agreement");
        },

        getAllSupplierAgreements: function () {
            return ApiService.get("/supplier-agreements");
        },

        acceptSupplierAgreement: function (id) {
            return ApiService.put("/supplier-agreement/" + id + "/accept");
        }
    };
});

angular.module("cpLib").filter("addressSingleLineFormatter", function ($sce) {
    return function (address) {
        var separator = arguments[1] === undefined ? ", " : arguments[1];
        if (!address) {
            return $sce.trustAsHtml("");
        }

        function safe(input) {
            return input.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        return $sce.trustAsHtml(safe(address.addressLine1) + (address.addressLine2 ? separator + safe(address.addressLine2) : "") + (address.addressLine3 ? separator + safe(address.addressLine3) : "") + (address.city ? separator + safe(address.city) : "") + (address.postcode ? separator + safe(address.postcode) : "") + (address.countryName ? separator + safe(address.countryName) : ""));
    };
});

angular.module("cpLib").filter("dateIgnoreTimezone", function ($filter) {
    /**
     * This filter takes a date string formatted as ISO 8601 and returns just the date formatted as
     * specified in the second parameter, regardless of the timezone in the input string or the
     * timezone on the user's computer.
     *
     * @param  {String} date
     * @param  {String format
     * @return {String}
     */
    return function (date, format) {
        return $filter("date")(date.replace(/(Z|[\+\-]\d{2}\:?\d{2})$/, ""), format);
    };
});

angular.module("cpLib").filter("dateIsBSTInEffect", function () {
    /**
     * This filter returns whether the date passed is inside British Summer Time. The timezone attached
     * to the date passed is ignored.
     *
     * @param  {String|Date} date
     * @return {Boolean}
     */
    return function (date) {
        if (typeof date === "string") {
            date = new Date(Date.parse(date));
        }

        // Loop over the 31 days of March for the current year.
        var lastSundayOfMarch = undefined;
        for (var i = 31; i > 0; i--) {
            var tempDate = new Date(date.getFullYear(), 2, i);

            if (tempDate.getDay() === 0) {
                lastSundayOfMarch = tempDate;
                break;
            }
        }

        // Loop over the 31 days of October for the current year.
        var lastSundayOfOctober = undefined;
        for (var i = 31; i > 0; i--) {
            var tempDate = new Date(date.getFullYear(), 9, i);

            if (tempDate.getDay() === 0) {
                lastSundayOfOctober = tempDate;
                break;
            }
        }

        return date > lastSundayOfMarch && date < lastSundayOfOctober;
    };
});

/**
 * Format dietary requirements as HTML.
 */
angular.module("cpLib").filter("dietaryRequirementsFormatter", function ($sce) {
    function escapeHtml(input) {
        return input.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    return function (dietaryRequirements) {
        if (!dietaryRequirements.customInstructions && !dietaryRequirements.requirements.length) {
            return $sce.trustAsHtml("None.");
        }

        var html = "";

        dietaryRequirements.requirements.forEach(function (group) {
            html += group.headCount + ": " + group.requirements.map(function (r) {
                return escapeHtml(r.name);
            }).join(" + ") + "<br />";
        });

        if (dietaryRequirements.customInstructions) {
            html += "Custom instructions:<br />" + dietaryRequirements.customInstructions.replace(/\n+$/, "").replace(/\n/g, "<br />");
        }

        html = html.replace(/(<br \/>)+$/, "");

        return $sce.trustAsHtml(html);
    };
});

angular.module("cpLib").filter("firstName", function () {
    return function (fullName) {
        return String(fullName).split(" ")[0];
    };
});

angular.module("cpLib").filter("getActiveAndApprovedStatusText", function () {
    return function (active, approved) {
        if (active === false && approved === false) {
            return "In progress";
        } else if (active === true && approved === false) {
            return "Awaiting approval";
        } else if (active === false && approved === true) {
            return "Inactive";
        } else if (active === true && approved === true) {
            return "Active";
        } else {
            throw new Error("Unexpected: active: " + active + ", approved: " + approved);
        }
    };
});

angular.module("cpLib").filter("getCardNumberMask", function () {
    return function (last4, type) {
        if (type === "American Express") {
            return "XXXX XXXXXX X" + last4;
        } else {
            return "XXXX XXXX XXXX " + last4;
        }
    };
});

angular.module("cpLib").filter("getCustomerMealPlanDurationText", function () {
    return function (duration) {
        switch (duration) {
            case 1:
            case "duration_two_weeks":
                return "Two weeks";
            case 2:
            case "duration_one_month":
                return "One month";
            case 3:
            case "duration_until_end_of_the_month":
                return "Until the end of the month";
            default:
                throw "Unexpected duration: " + duration;
        }
    };
});

angular.module("cpLib").filter("getCustomerMealPlanStatusText", function () {
    return function (customerMealPlanStatus) {
        switch (customerMealPlanStatus) {
            case 1:
                return "None";
            case 2:
                return "Requested callback";
            case 3:
                return "Pending first generation";
            case 4:
                return "Pending first staff approval";
            case 5:
                return "Active";
            default:
                throw "Unexpected customerMealPlanStatus: " + customerMealPlanStatus;
        }
    };
});

angular.module("cpLib").filter("getDeliveryStatusText", function () {
    return function (deliveryStatus) {
        switch (deliveryStatus) {
            case 1:
                return "Left the kitchen";
            case 2:
                return "Late < 15 mins";
            case 3:
                return "Late > 15 mins - call";
            case 4:
                return "Delivered";
            default:
                return "Unknown";
        }
    };
});

angular.module("cpLib").filter("getInvoiceStatusText", function () {
    return function (status) {
        switch (status) {
            case "awaiting_payment":
                return {
                    actionText: "Paid",
                    statusText: "Awaiting payment"
                };
            case "paid":
                return {
                    actionText: "Awaiting payment",
                    statusText: "Paid"
                };
            default:
                throw "Unexpected status: " + status;
        }
    };
});

angular.module("cpLib").filter("getMealPlanStatusText", function () {
    return function (mealPlanStatus) {
        switch (mealPlanStatus) {
            case 2:
                return "Pending staff approval";
            case 4:
                return "Pending customer approval";
            case 3:
                return "Active";
            default:
                return "Unknown";
        }
    };
});

angular.module("cpLib").filter("getNewInvoiceStatus", function (INVOICE_STATUS_AWAITING_PAYMENT, INVOICE_STATUS_PAID) {
    return function (status) {
        switch (status) {
            case "awaiting_payment":
                return INVOICE_STATUS_PAID;
            case "paid":
                return INVOICE_STATUS_AWAITING_PAYMENT;
            default:
                throw "Unexpected status: " + status;
        }
    };
});

angular.module("cpLib").filter("getOrderStatusText", function () {
    return function (status) {
        switch (status) {
            case "pending_vendor_approval":
                return "Pending vendor approval";
            case "accepted":
                return "Active";
            default:
                throw "Unexpected status: " + status;
        }
    };
});

angular.module("cpLib").filter("getPackageAvailabilityErrorText", function () {
    return function (availability) {
        if (!availability.isPostcodeOk) {
            return "This meal cannot be delivered to your location.";
        } else if (availability.isVendorDailyCapacityExceeded) {
            return "The vendor has too many orders on this day.";
        } else if (!availability.isDateOk) {
            return "This meal cannot be delivered on this date.";
        } else if (!availability.isTimeOk) {
            return "This meal cannot be delivered at this time.";
        } else if (!availability.isEnoughNotice) {
            return "The vendor needs more notice to deliver at this time.";
        } else if (availability.isVendorOnHoliday) {
            return "The vendor is on holiday on that date.";
        } else {
            throw new Error("Unknown error: isPostcodeOk: " + availability.isPostcodeOk + ", isVendorDailyCapacityExceeded: " + availability.isVendorDailyCapacityExceeded + ", isDateOk: " + availability.isDateOk + ", isTimeOk: " + availability.isTimeOk + ", isEnoughNotice: " + availability.isEnoughNotice + ", isVendorOnHoliday: " + availability.isVendorOnHoliday);
        }
    };
});

angular.module("cpLib").filter("getPackageDispositionText", function () {
    return function (disposition) {
        switch (disposition) {
            case "must_have":
            case 1:
                return "Must have";
            case "must_not_have":
            case 2:
                return "Must not have";
            default:
                throw "Unexpected disposition: " + disposition;
        }
    };
});

angular.module("cpLib").filter("getPackagingTypeChoiceText", function () {
    return function (type) {
        switch (type) {
            case "individual":
            case 1:
                return "Individual portions";
            case "buffet":
            case 2:
                return "Buffet";
            case "dont_mind":
            case 3:
                return "Don’t care";
            default:
                throw "Unexpected type: " + type;
        }
    };
});

angular.module("cpLib").filter("getPackagingTypeText", function () {
    return function (type) {
        switch (type) {
            case "individual":
            case 1:
                return "Individual";
            case "buffet":
            case 2:
                return "Buffet";
            case "either":
            case 3:
                return "Either";
            case "special":
            case 4:
                return "Special";
            case "n/a":
            case "N/A":
            case 5:
                return "N/A";
            default:
                throw "Unexpected type: " + type;
        }
    };
});

angular.module("cpLib").filter("getPaidOnAccountStatusText", function () {
    return function (paidOnAccountStatus) {
        switch (paidOnAccountStatus) {
            case 0:
            case "disabled":
                return "Disabled";
            case 1:
            case "additional_information_needed":
                return "Additional information needed";
            case 2:
            case "enabled":
                return "Enabled";
            default:
                throw "Unexpected paidOnAccountStatus: " + paidOnAccountStatus;
        }
    };
});

angular.module("cpLib").filter("getPayOnAccountStatusText", function () {
    return function (isPayOnAccount) {
        if (isPayOnAccount === false) {
            return "No";
        } else if (isPayOnAccount === true) {
            return "Yes";
        } else {
            throw new Error("Unexpected: isPayOnAccount: " + isPayOnAccount);
        }
    };
});

angular.module("cpLib").filter("getPromoCodeErrorText", function () {
    return function (code) {
        return "Promo code " + code + " has expired";
    };
});

angular.module("cpLib").filter("slugify", function () {
    return function (text) {
        return String(text).replace(/ +/g, "-").replace(/\//g, "-").replace(/-{2,}/g, "-").replace(/(.)[\.-]*$/, "$1").toLowerCase();
    };
});

angular.module("cpLib").service("ApiService", function ($http, ApiAuthService, API_BASE) {
    function addAuthHeaders() {
        var config = arguments[0] === undefined ? {} : arguments[0];
        config.headers = config.headers || {};
        config.headers["X-CityPantry-UserId"] = ApiAuthService().userId;
        config.headers["X-CityPantry-AuthToken"] = ApiAuthService().authToken;

        return config;
    }

    return {
        get: function (url, config) {
            config = addAuthHeaders(config);

            return $http.get(API_BASE + url, config);
        },

        post: function (url, data, config) {
            config = addAuthHeaders(config);

            return $http.post(API_BASE + url, data, config);
        },

        put: function (url, data, config) {
            config = addAuthHeaders(config);

            return $http.put(API_BASE + url, data, config);
        },

        "delete": function (url, config) {
            config = addAuthHeaders(config);

            return $http["delete"](API_BASE + url, config);
        },

        getAuthHeaders: function () {
            return {
                "X-CityPantry-UserId": ApiAuthService().userId,
                "X-CityPantry-AuthToken": ApiAuthService().authToken };
        }
    };
});