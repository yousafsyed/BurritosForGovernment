angular.module('cpLib', ['cpLibIntegration']);

angular.module('cpLib').factory('AddressFactory', function(ApiService) {
    return {
        getAddresses: () => ApiService.get(`/addresses`),

        getAddressesByVendorId: (id) => ApiService.get(`/addresses/vendor/${id}`),

        getAddressesByCustomerId: (id) => ApiService.get(`/addresses/customer/${id}`),

        createAddress: (address, customerId = '') => ApiService.post(`/addresses`, {address: address, customerId: customerId}),

        updateAddress: (id, updatedAddress) => ApiService.put(`/addresses/${id}`, updatedAddress),

        deleteAddress: (id) => ApiService.delete(`/addresses/${id}`),

        createBillingAddress: (address, customerId = '') => ApiService.post(`/addresses/billing-address`, {address: address, customerId: customerId})
    };
});

angular.module('cpLib').factory('AuthenticationFactory', function(ApiService) {
    return {
        login: loginDetails => ApiService.post(`/user/login`, loginDetails),

        registerCustomer: registerDetails => ApiService.post(`/user/register-customer`, registerDetails),

        requestResetEmail: email => ApiService.post(`/user/request-reset-email`, email),

        setPassword: resetDetails => ApiService.post(`/user/set-password`, resetDetails)
    };
});

angular.module('cpLib').factory('CustomersFactory', function(ApiService, $q) {
    return {
        getAllCustomers: () => ApiService.get(`/customers`),

        getCustomer: id => ApiService.get(`/customers/${id}`),

        updateCustomer: (id, updatedCustomer) => ApiService.put(`/customers/${id}`, updatedCustomer),

        updateSelf: attributes => ApiService.put(`/customers/self`, attributes),

        getAddresses: () => ApiService.get(`/addresses`),

        getAddressById: id => {
            const pluckMatchingAddress = response => {
                const allAddresses = response.data.addresses,
                    allIds = allAddresses.map(address => address.id),
                    address = allAddresses[allIds.indexOf(id)];

                if (address) {
                    return address;
                } else {
                    throw 'Couldn’t find address';
                }
            };

            return ApiService.get(`/addresses`).then(pluckMatchingAddress);
        },

        getCustomerReviews: (id) => ApiService.get(`/reviews/customer/${id}`),

        updatePayOnAccountDetails: (payOnAccountDetails) => ApiService.put(`/customers/pay-on-account`, payOnAccountDetails),

        setUpRequestToPayOnAccount: (id, payOnAccountDetails) => ApiService.put(`/customers/${id}/set-up-request-to-pay-on-account`, payOnAccountDetails),

        revokePaymentOnAccount: (id) => ApiService.put(`/customers/${id}/revoke-payment-on-account`)
    };
});

angular.module('cpLib').factory('MealPlanFactory', function (ApiService) {
    return {
        getCustomers: () => ApiService.get(`/meal-plan/customers`),

        getCustomerMealPlanRequirements: (id) => ApiService.get(`/meal-plan/customers/${id}/requirements`),

        setCustomerMealPlanRequirements: (id, mealPlanRequirements) => ApiService.post(`/meal-plan/customers/${id}/requirements`, mealPlanRequirements),

        generateMealPlan: (id, startDate) => ApiService.post(`/meal-plan/customers/${id}/generate`, {startDate: startDate}),

        registerForMealPlan: (registrationDetails) => ApiService.post(`/meal-plan/register`, registrationDetails),

        getCustomerMealPlans: (customerId) => ApiService.get(`/meal-plan/customers/${customerId}/meal-plans`),

        getCustomerMealPlan: (customerId, mealPlanId) => ApiService.get(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}`),

        checkProposedOrdersAvailability: (customerId, mealPlanId, proposedOrders) => ApiService.post(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}/availability`, {checks: proposedOrders}),

        setPackagesOnDates: (customerId, mealPlanId, orders) => ApiService.post(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}/set-package-dates`, {orders: orders}),

        /**
         * @param  {String} customerId
         * @param  {String} mealPlanId
         * @param  {String} date       An ISO-8601 string.
         */
        replaceWithUnusedAlternativePackage: (customerId, mealPlanId, date) => ApiService.post(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}/replace-with-unused-alternative-package`, date),

        sendToCustomer: (customerId, mealPlanId) => ApiService.post(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}/send-to-customer`),

        confirmProposedOrders: (customerId, mealPlanId, attributes) => ApiService.post(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}/confirm-proposed-orders`, attributes),

        editProposedOrder: (customerId, mealPlanId, orderDetails) => ApiService.post(`/meal-plan/customers/${customerId}/meal-plans/${mealPlanId}/edit-proposed-order`, orderDetails)
    };
});

angular.module('cpLib').factory('OrdersFactory', function(ApiService) {
    // Cache of Date objects, to avoid having to create a new Date object many times when running
    // an array filter or sort.
    const dateObjectCache = {};

    const getDateObject = (date) => {
        if (dateObjectCache[date] === undefined) {
            dateObjectCache[date] = new Date(date);
        }

        return dateObjectCache[date];
    };

    return {
        getAllOrders: () => ApiService.get(`/orders`),

        getOrdersByCurrentVendor: () => ApiService.get(`/orders/by-current-vendor`),

        getOrdersByCurrentCustomer: () => ApiService.get(`/orders/by-current-customer`),

        /**
         * Get the next order for a customer, which can have either the status 'pending vendor
         * approval' or 'accepted'.
         *
         * @return {Promise} Resolves to an order, or null if there is none.
         */
        getNextCustomerOrder() {
            return this.getOrdersByCurrentCustomer()
                .then((response) => {
                    const orders = response.data.orders;
                    if (orders.length === 0) {
                        return null;
                    }

                    const now = new Date();

                    return orders.filter((order) => getDateObject(order.requestedDeliveryDate) >= now)
                        .sort((a, b) => getDateObject(a.requestedDeliveryDate) - getDateObject(b.requestedDeliveryDate))
                        .shift();
                });
        },

        getOrder: (id) => ApiService.get(`/orders/${id}`),

        getOrderMessages: (id) => ApiService.get(`/orders/${id}/messages`),

        getOrderReviews: (id) => ApiService.get(`/reviews/order/${id}`),

        sendMessage: (id, message) => ApiService.put(`/orders/${id}/messages`, {message: message}),

        updateOrder: (id, updatedOrder) => ApiService.put(`/order/${id}`, updatedOrder),

        deleteOrder: (id, reason = '') => ApiService.delete(`/order/${id}?deletionReason=${reason}`),

        getCourierOrders: () => ApiService.get(`/orders/courier`),

        addCustomerServiceEvent: (id, event) => ApiService.post(`/order/${id}/customer-service-events`, {event: event}),

        acceptOrder: (id) => ApiService.put(`/order/${id}/accept`),

        addOrderReview: (id, review) => ApiService.post(`/reviews/order/${id}`, review),

        getHeadCountOptions(maxPeople = 1, minPeople = 1) {
            if (maxPeople === null) {
                maxPeople = 1000;
            }
            if (minPeople === null) {
                minPeople = 1;
            }

            const options = [];

            for (let i = minPeople; i <= maxPeople; i += 1) {
                options.push(i);
            }

            return options;
        },

        getAllCustomerInvoices: () => ApiService.get(`/orders/customer-invoices`),

        getCustomerInvoice: (id) => ApiService.get(`/orders/customer-invoice/${id}`),

        getCustomerInvoiceAsHtml: (id) => ApiService.get(`/orders/customer-invoice-as-html/${id}`),

        updateCustomerInvoiceStatus: (id, status) => ApiService.put(`/orders/customer-invoice/${id}/status`, {status: status}),

        refundOrder: (id, refundDetails) => ApiService.put(`/order/${id}/refund`, refundDetails),

        getOrderInvoices: (orderId) => ApiService.get(`/orders/customer-invoices-by-order/${orderId}`),

        createOrder: orderDetails => ApiService.post(`/orders`, orderDetails)
    };
});

angular.module('cpLib').factory('PackagesFactory',
        function(ApiService, getPackagingTypeTextFilter, getPackagingTypeChoiceTextFilter,
        getPackageDispositionTextFilter) {
    return {
        getAllPackages: () => ApiService.get(`/packages`),

        getPackage: id => ApiService.get(`/packages/${id}`),

        getPackageByHumanId: humanId => ApiService.get(`/packages/${humanId}`),

        /**
         * Resolves to the name of a package.
         *
         * @param {String|Number} id Either the package ID or the package human ID.
         */
        getPackageName: (id) => ApiService.get(`/packages/${id}`)
            .then(response => response.data.name),

        createPackage: packageDetails => ApiService.post(`/packages`, packageDetails),

        updatePackage: (id, updatedPackage) => ApiService.put(`/packages/${id}`, updatedPackage),

        deletePackage: id => ApiService.delete(`/packages/${id}`),

        /**
         * @param {Promise} timeoutPromise Optional promise that is passed to the $http service as
         *                                  it's `timeout` config option. This is used to cancel a
         *                                  search if a new search request is started before the
         *                                  previous request returns.
         */
        searchPackages(name = '', postcode = '', maxBudget = '', headCount = '', time = '', date = '',
                eventTypeIds = [], cuisineTypeIds = [], dietaryRequirementIds = [], packagingType = '',
                timeoutPromise = undefined) {
            let url = `/packages/search?name=${name}&postcode=${postcode}` +
                `&maxBudget=${maxBudget}&headCount=${headCount}&time=${time}&date=${date}&packagingType=${packagingType}`;

            eventTypeIds.forEach(eventTypeId => {
                url += `&eventTypeIds[]=${eventTypeId}`;
            });

            cuisineTypeIds.forEach(cuisineTypeId => {
                url += `&cuisineTypeIds[]=${cuisineTypeId}`;
            });

            dietaryRequirementIds.forEach(dietaryRequirementId => {
                url += `&dietaryRequirementIds[]=${dietaryRequirementId}`;
            });

            return ApiService.get(url, {timeout: timeoutPromise});
        },

        getPackagesByVendor: id => ApiService.get(`/packages/search/all?vendorId=${id}`),

        getPackagesByCurrentVendor: () => ApiService.get(`/packages/by-current-vendor`),

        getPackageReviews: id => ApiService.get(`/reviews/package/${id}`),

        getSimilarPackages: id => ApiService.get(`/packages/${id}/similar`),

        approvePackage: (id) => ApiService.put(`/packages/${id}/approve`),

        getAllergenTypes: () => ApiService.get(`/allergen-types`),

        getDietaryTypes: () => ApiService.get(`/dietary-requirements`),

        getEventTypes: () => ApiService.get(`/event-types`),

        getCuisineTypes: () => ApiService.get(`/cuisine-types`),

        getDeliveryDayOptions: () => {
            return [
                { label: 'Monday',    value: 'Monday' },
                { label: 'Tuesday',   value: 'Tuesday' },
                { label: 'Wednesday', value: 'Wednesday' },
                { label: 'Thursday',  value: 'Thursday' },
                { label: 'Friday',    value: 'Friday' },
                { label: 'Saturday',  value: 'Saturday' },
                { label: 'Sunday',    value: 'Sunday' }
            ];
        },

        /**
         * Gets an array of possible notice options for a package.
         *
         * If the package is a meal plan package, there is a maximum notice.
         *
         * @param  {Boolean} isForMealPlanPackage
         * @return {Array}
         */
        getNoticeOptions: (isForMealPlanPackage = false) => {
            const allNoticeOptions = [
                { label: '1 hour',   value: 1 },
                { label: '2 hours',  value: 2 },
                { label: '3 hours',  value: 3 },
                { label: '4 hours',  value: 4 },
                { label: '5 hours',  value: 5 },
                { label: '6 hours',  value: 6 },
                { label: '12 hours', value: 12 },
                { label: '18 hours', value: 18 },
                { label: '24 hours', value: 24 },
                { label: '36 hours', value: 36 },
                { label: '2 days',   value: 48 },
                { label: '3 days',   value: 72 },
                { label: '4 days',   value: 96 },
                { label: '5 days',   value: 120 },
                { label: '6 days',   value: 144 },
                { label: '7 days',   value: 168 },
                { label: '14 days',  value: 336 }
            ];

            if (isForMealPlanPackage) {
                return allNoticeOptions.slice(0, 9);
            } else {
                return allNoticeOptions;
            }
        },

        getQuantityOptions: () => {
            var i = 1;
            var step = 1;

            const options = [];

            while (i <= 6000) {
                options.push(i);

                if (30 <= i && i < 100) {
                    step = 5;
                } else if (100 <= i && i < 500) {
                    step = 25;
                } else if (500 <= i && i < 1000) {
                    step = 50;
                } else if (i >= 1000) {
                    step = 500;
                }

                i += step;
            }

            return options;
        },

        getRadiusOptions: () => {
            const options = [];

            for (let i = 1, step = 1; i <= 50; i += step) {
                options.push({
                    label: i + ' mile radius',
                    value: i
                });
                if (i === 5) {
                    step = 5;
                }
            }

            return options;
        },

        getPackagingTypeOptions: () => {
            return [1, 2, 3, 4, 5].map(value => ({ value, label: getPackagingTypeTextFilter(value) }));
        },

        getPackagingTypeChoiceOptions: () => {
            return [1, 2, 3].map(value => ({ value, label: getPackagingTypeChoiceTextFilter(value) }));
        },

        /**
         * The 'start' and 'end' parameters should be the time in 24-hour clock as an integer,
         * e.g. 730 for 07:30, or 2330 for 23:30.
         *
         * @param  {Number} start
         * @param  {Number} end
         * @param  {Number} interval
         * @return {Array}
         */
        getPackageDeliveryTimeOptions: (start, end, interval = 15) => {
            let startMinutes = (Math.floor(start / 100) * 60) + (start % 100);
            let endMinutes = (Math.floor(end / 100) * 60) + (end % 100);

            const options = [];

            while (startMinutes <= endMinutes) {
                const hour = ('0' + Math.floor(startMinutes / 60)).slice(-2);
                const minute = ('0' + startMinutes % 60).slice(-2);

                options.push({
                    label: hour + ':' + minute,
                    value: parseInt(hour + minute, 10)
                });

                startMinutes += interval;
            }

            return options;
        },

        checkIfPackageCanBeDeliveredToPostcode: (id, postcode) => ApiService.get(`/packages/${id}/availability?postcode=${postcode}`),

        checkIfPackageCanBeDelivered: (id, date, time, postcode) => ApiService.get(`/packages/${id}/availability?date=${date}&time=${time}&postcode=${postcode}`),

        getRecommendedPackage: () => ApiService.get(`/packages/one-recommended`),

        getPackageDispositionOptions: () => {
            return [1, 2].map(value => ({ value, label: getPackageDispositionTextFilter(value) }));
        }
    };
});

angular.module('cpLib').factory('PromoCodeFactory', function(ApiService) {
    return {
        getPromoCodeByCode: code => ApiService.get(`/promo-codes/get-by-code?code=${code}`)
    };
});

angular.module('cpLib').factory('QuoteFactory', function(ApiService) {
    return {
        sendQuote: quoteDetails => ApiService.post(`/quote/send-quote`, quoteDetails)
    };
});

angular.module('cpLib').factory('ReportingFactory', function(ApiService) {
    return {
        queryDatabase: (query) => {
            const config = {
                // Angular will try to parse responses as JSON by default. The response from this
                // API can be in any format, so turn off the JSON parsing,
                transformResponse: [function(responseContent) {
                    return responseContent;
                }]
            };
            return ApiService.post(`/reporting/database-query`, {query: query}, config);
        },
    };
});

angular.module('cpLib').factory('ReviewFactory', function(ApiService) {
    return {
        setReviewAsPublic: (isPublic, reviewId) => ApiService.put(`/reviews/${reviewId}/set-as-public`, {isPublic: isPublic}),
    };
});

angular.module('cpLib').factory('SmsFactory', function (ApiService) {
    return {
        getSms: (id) => ApiService.get(`/sms/${id}`),

        sendSms: (sms) => ApiService.post(`/sms`, sms),

        getSmsHistory: () => ApiService.get(`/sms`),

        getAllSmsByNumber: (number) => ApiService.get(`/sms/${number}/all`)
    };
});

angular.module('cpLib').factory('UsersFactory', function(ApiService) {
    return {
        getAllUsers: () => ApiService.get(`/users`),

        masqueradeAsUser: id => ApiService.post(`/user/masquerade`, {id: id}),

        getLoggedInUser: (id = '', oneTimeAuthToken = '') => ApiService.get(`/users/get-authenticated-user?userId=${id}&otat=${oneTimeAuthToken}`),

        registerVendor: registerDetails => ApiService.post(`/user/register-vendor`, registerDetails),

        changeOwnPassword: passwords => ApiService.put(`/user/self/change-password`, passwords),

        getPaymentCards: () => ApiService.get(`/payment-cards`),

        addPaymentCard: (cardDetails) => ApiService.post(`/payment-cards`, cardDetails)
    };
});

angular.module('cpLib').factory('VendorsFactory', function(ApiService, $q) {
    return {
        getAllVendors: () => ApiService.get(`/vendors`),

        getAllActiveAndApprovedVendors: () => ApiService.get(`/vendors/all-active-and-approved`),

        getVendor: (idOrSlug) => ApiService.get(`/vendors/${idOrSlug}`),

        getAddresses: () => ApiService.get(`/addresses`),

        getAddressById: id => {
            const pluckMatchingAddress = response => {
                const allAddresses = response.data.addresses,
                    allIds = allAddresses.map(address => address.id),
                    address = allAddresses[allIds.indexOf(id)];

                if (address) {
                    return address;
                } else {
                    throw 'Couldn’t find address';
                }
            };

            return ApiService.get(`/addresses`).then(pluckMatchingAddress);
        },

        getBusinessTypes: () => ApiService.get(`/business-types`),

        getVendorReviews: (id) => ApiService.get(`/reviews/vendor/${id}`),

        updateVendor: (id, updatedVendor) => ApiService.put(`/vendors/${id}`, updatedVendor),

        updateSelf: (updatedVendor) => ApiService.put(`/vendors/me`, updatedVendor),

        deleteVendor: (id) => ApiService.delete(`/vendors/${id}`),

        approveVendor: (id) => ApiService.put(`/vendors/${id}/approve`),

        getHolidays: () => ApiService.get(`/holidays`),

        /**
         * @param {String} start Formatted as 'YYYY-MM-DD'.
         * @param {String} end   Formatted as 'YYYY-MM-DD'.
         */
        createHoliday: (start, end) => ApiService.post(`/holidays`, {start: start, end: end}),

        getHoliday: (id) => ApiService.get(`/holidays/${id}`),

        updateHoliday: (id, start, end) => ApiService.put(`/holidays/${id}`, {start: start, end: end}),

        getLatestSupplierAgreement: () => ApiService.get(`/supplier-agreement`),

        getAllSupplierAgreements: () => ApiService.get(`/supplier-agreements`),

        acceptSupplierAgreement: (id) => ApiService.put(`/supplier-agreement/${id}/accept`)
    };
});

angular.module('cpLib').filter('addressSingleLineFormatter', function($sce) {
    return (address, separator = ', ') => {
        if (!address) {
            return $sce.trustAsHtml('');
        }

        function safe(input) {
            return input.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        return $sce.trustAsHtml(safe(address.addressLine1) +
            (address.addressLine2 ? separator + safe(address.addressLine2) : '') +
            (address.addressLine3 ? separator + safe(address.addressLine3) : '') +
            (address.city ? separator + safe(address.city) : '') +
            (address.postcode ? separator + safe(address.postcode) : '') +
            (address.countryName ? separator + safe(address.countryName) : ''));
    };
});

angular.module('cpLib').filter('dateIgnoreTimezone', function($filter) {
    /**
     * This filter takes a date string formatted as ISO 8601 and returns just the date formatted as
     * specified in the second parameter, regardless of the timezone in the input string or the
     * timezone on the user's computer.
     *
     * @param  {String} date
     * @param  {String format
     * @return {String}
     */
    return (date, format) => $filter('date')(date.replace(/(Z|[\+\-]\d{2}\:?\d{2})$/, ''), format);
});

angular.module('cpLib').filter('dateIsBSTInEffect', function() {
    /**
     * This filter returns whether the date passed is inside British Summer Time. The timezone attached
     * to the date passed is ignored.
     *
     * @param  {String|Date} date
     * @return {Boolean}
     */
    return (date) => {
        if (typeof date === 'string') {
            date = new Date(Date.parse(date));
        }

        // Loop over the 31 days of March for the current year.
        let lastSundayOfMarch;
        for (let i = 31; i > 0; i--) {
            let tempDate = new Date(date.getFullYear(), 2, i);

            if (tempDate.getDay() === 0) {
                lastSundayOfMarch = tempDate;
                break;
            }
        }

        // Loop over the 31 days of October for the current year.
        let lastSundayOfOctober;
        for (let i = 31; i > 0; i--) {
            let tempDate = new Date(date.getFullYear(), 9, i);

            if (tempDate.getDay() === 0) {
                lastSundayOfOctober = tempDate;
                break;
            }
        }

        return (date > lastSundayOfMarch && date < lastSundayOfOctober);
    };
});

/**
 * Format dietary requirements as HTML.
 */
angular.module('cpLib').filter('dietaryRequirementsFormatter', function($sce) {
    function escapeHtml(input) {
        return input.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    return (dietaryRequirements) => {
        if (!dietaryRequirements.customInstructions && !dietaryRequirements.requirements.length) {
            return $sce.trustAsHtml('None.');
        }

        let html = '';

        dietaryRequirements.requirements.forEach(group => {
            html += group.headCount + ': ' + group.requirements.map(r => escapeHtml(r.name)).join(' + ') + '<br />';
        });

        if (dietaryRequirements.customInstructions) {
            html += 'Custom instructions:<br />' +
                dietaryRequirements.customInstructions.replace(/\n+$/, '').replace(/\n/g, '<br />');
        }

        html = html.replace(/(<br \/>)+$/, '');

        return $sce.trustAsHtml(html);
    };
});

angular.module('cpLib').filter('firstName', function() {
    return fullName => String(fullName).split(' ')[0];
});

angular.module('cpLib').filter('getActiveAndApprovedStatusText', function() {
    return function(active, approved) {
        if (active === false && approved === false) {
            return 'In progress';
        } else if (active === true && approved === false) {
            return 'Awaiting approval';
        } else if (active === false && approved === true) {
            return 'Inactive';
        } else if (active === true && approved === true) {
            return 'Active';
        } else {
            throw new Error('Unexpected: active: ' + active + ', approved: ' + approved);
        }
    };
});

angular.module('cpLib').filter('getCardNumberMask', function() {
    return function(last4, type) {
        if (type === 'American Express') {
            return 'XXXX XXXXXX X' + last4;
        } else {
            return 'XXXX XXXX XXXX ' + last4;
        }
    };
});

angular.module('cpLib').filter('getCustomerMealPlanDurationText', function() {
    return function(duration) {
        switch (duration) {
            case 1:
            case 'duration_two_weeks':
                return 'Two weeks';
            case 2:
            case 'duration_one_month':
                return 'One month';
            case 3:
            case 'duration_until_end_of_the_month':
                return 'Until the end of the month';
            default:
                throw 'Unexpected duration: ' + duration;
        }
    };
});

angular.module('cpLib').filter('getCustomerMealPlanStatusText', function() {
    return function(customerMealPlanStatus) {
        switch (customerMealPlanStatus) {
            case 1:
                return 'None';
            case 2:
                return 'Requested callback';
            case 3:
                return 'Pending first generation';
            case 4:
                return 'Pending first staff approval';
            case 5:
                return 'Active';
            default:
                throw 'Unexpected customerMealPlanStatus: ' + customerMealPlanStatus;
        }
    };
});

angular.module('cpLib').filter('getDeliveryStatusText', function() {
    return function(deliveryStatus) {
        switch (deliveryStatus) {
            case 1:
                return 'Left the kitchen';
            case 2:
                return 'Late < 15 mins';
            case 3:
                return 'Late > 15 mins - call';
            case 4:
                return 'Delivered';
            default:
                return 'Unknown';
        }
    };
});

angular.module('cpLib').filter('getInvoiceStatusText', function() {
    return function(status) {
        switch (status) {
            case 'awaiting_payment':
                return {
                    actionText: 'Paid',
                    statusText: 'Awaiting payment'
                };
            case 'paid':
                return {
                    actionText: 'Awaiting payment',
                    statusText: 'Paid'
                };
            default:
                throw 'Unexpected status: ' + status;
        }
    };
});

angular.module('cpLib').filter('getMealPlanStatusText', function() {
    return function(mealPlanStatus) {
        switch (mealPlanStatus) {
            case 2:
                return 'Pending staff approval';
            case 4:
                return 'Pending customer approval';
            case 3:
                return 'Active';
            default:
                return 'Unknown';
        }
    };
});

angular.module('cpLib').filter('getNewInvoiceStatus', function(
        INVOICE_STATUS_AWAITING_PAYMENT, INVOICE_STATUS_PAID) {
    return function(status) {
        switch (status) {
            case 'awaiting_payment':
                return INVOICE_STATUS_PAID;
            case 'paid':
                return INVOICE_STATUS_AWAITING_PAYMENT;
            default:
                throw 'Unexpected status: ' + status;
        }
    };
});

angular.module('cpLib').filter('getOrderStatusText', function() {
    return function(status) {
        switch (status) {
            case 'pending_vendor_approval':
                return 'Pending vendor approval';
            case 'accepted':
                return 'Active';
            default:
                throw 'Unexpected status: ' + status;
        }
    };
});

angular.module('cpLib').filter('getPackageAvailabilityErrorText', function() {
    return function(availability) {
        if (!availability.isPostcodeOk) {
            return 'This meal cannot be delivered to your location.';
        } else if (availability.isVendorDailyCapacityExceeded) {
            return 'The vendor has too many orders on this day.';
        } else if (!availability.isDateOk) {
            return 'This meal cannot be delivered on this date.';
        } else if (!availability.isTimeOk) {
            return 'This meal cannot be delivered at this time.';
        } else if (!availability.isEnoughNotice) {
            return 'The vendor needs more notice to deliver at this time.';
        } else if (availability.isVendorOnHoliday) {
            return 'The vendor is on holiday on that date.';
        } else {
            throw new Error('Unknown error: isPostcodeOk: ' + availability.isPostcodeOk +
                ', isVendorDailyCapacityExceeded: ' + availability.isVendorDailyCapacityExceeded +
                ', isDateOk: ' + availability.isDateOk + ', isTimeOk: ' + availability.isTimeOk +
                ', isEnoughNotice: ' + availability.isEnoughNotice +
                ', isVendorOnHoliday: ' + availability.isVendorOnHoliday
            );
        }
    };
});

angular.module('cpLib').filter('getPackageDispositionText', function() {
    return function(disposition) {
        switch (disposition) {
            case 'must_have':
            case 1:
                return 'Must have';
            case 'must_not_have':
            case 2:
                return 'Must not have';
            default:
                throw 'Unexpected disposition: ' + disposition;
        }
    };
});

angular.module('cpLib').filter('getPackagingTypeChoiceText', function() {
    return function(type) {
        switch (type) {
            case 'individual':
            case 1:
                return 'Individual portions';
            case 'buffet':
            case 2:
                return 'Buffet';
            case 'dont_mind':
            case 3:
                return 'Don’t care';
            default:
                throw 'Unexpected type: ' + type;
        }
    };
});

angular.module('cpLib').filter('getPackagingTypeText', function() {
    return function(type) {
        switch (type) {
            case 'individual':
            case 1:
                return 'Individual';
            case 'buffet':
            case 2:
                return 'Buffet';
            case 'either':
            case 3:
                return 'Either';
            case 'special':
            case 4:
                return 'Special';
            case 'n/a':
            case 'N/A':
            case 5:
                return 'N/A';
            default:
                throw 'Unexpected type: ' + type;
        }
    };
});

angular.module('cpLib').filter('getPaidOnAccountStatusText', function() {
    return function(paidOnAccountStatus) {
        switch (paidOnAccountStatus) {
            case 0:
            case 'disabled':
                return 'Disabled';
            case 1:
            case 'additional_information_needed':
                return 'Additional information needed';
            case 2:
            case 'enabled':
                return 'Enabled';
            default:
                throw 'Unexpected paidOnAccountStatus: ' + paidOnAccountStatus;
        }
    };
});

angular.module('cpLib').filter('getPayOnAccountStatusText', function() {
    return function(isPayOnAccount) {
        if (isPayOnAccount === false) {
            return 'No';
        } else if (isPayOnAccount === true) {
            return 'Yes';
        } else {
            throw new Error('Unexpected: isPayOnAccount: ' + isPayOnAccount);
        }
    };
});

angular.module('cpLib').filter('getPromoCodeErrorText', function() {
    return function(code) {
        return 'Promo code ' + code + ' has expired';
    };
});

angular.module('cpLib').filter('slugify', function() {
    return text => String(text)
        .replace(/ +/g, '-')
        .replace(/\//g, '-')
        .replace(/-{2,}/g, '-')
        .replace(/(.)[\.-]*$/, '$1')
        .toLowerCase();
});

angular.module('cpLib').service('ApiService', function($http, ApiAuthService, API_BASE) {
    function addAuthHeaders(config = {}) {
        config.headers = config.headers || {};
        config.headers['X-CityPantry-UserId'] = ApiAuthService().userId;
        config.headers['X-CityPantry-AuthToken'] = ApiAuthService().authToken;

        return config;
    }

    return {
        get: function(url, config) {
            config = addAuthHeaders(config);

            return $http.get(API_BASE + url, config);
        },

        post: function(url, data, config) {
            config = addAuthHeaders(config);

            return $http.post(API_BASE + url, data, config);
        },

        put: function(url, data, config) {
            config = addAuthHeaders(config);

            return $http.put(API_BASE + url, data, config);
        },

        'delete': function(url, config) {
            config = addAuthHeaders(config);

            return $http.delete(API_BASE + url, config);
        },

        getAuthHeaders: function() {
            return {
                'X-CityPantry-UserId': ApiAuthService().userId,
                'X-CityPantry-AuthToken': ApiAuthService().authToken,
            };
        }
    };
});
